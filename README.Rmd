---
output: github_document
always_allow_html: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# track2dm

<!-- badges: start -->
<!-- badges: end -->

The goal of track2dm is to create detection matrix from transect lines that account for topography variability. The detection matrix is usually used for hierarchical modelling of species occupancy and distribution (see MacKenzie et al., 2004 about occupancy modelling).

## Installation

You can install the released version of track2dm and the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("ilubis85/track2dm")
```
## How does it work?

We have provided some dataset to play with to understand how the package works. Three types of data are needed, the track where the survey is recorded spatially, the observation along the tracks and elevation as raster data downloaded from USGS website.

```{r example}
# LOAD ALL DATA
# Read elevation raster data from the package
data("elevation")

# Read a survey track from the package
data("track")

# Read the observation from the package
data("observation")

# Convert dataframe (track and observation to spatial points data-frame)
track_pt <- track2dm::df2sp(track, UTMZone = "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs")
observation_pt <- track2dm::df2sp(observation, UTMZone = "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs")

```

Track is a dataframe contains date and time, X, Y and usually Z information downloaded from GPS. Whilst observation is a dataframe contains any information about the observed species. The elevation is needed to extract Z values to calculate distance in three dimension (3D).

```{r track}
head(track, 5)
head(observation, 5)
```

This figure below shows what the data look like when we plot them using tmap package. The data is used with permission from WCS Indonesia and the data has been published in journal of (TO BE UPDATED)!!.

```{r fig_1, out.width='100%', fig.align='center',  fig.pos="H", fig.cap="Survey tracks and points with elevation information", collapse = TRUE, echo = FALSE}
library(tmap)
tm_shape(elevation) +
  tm_raster(style = "cont") +
  tm_shape(track_pt) + tm_dots(col = "grey", shape=20, size=0.5) +
  tm_shape(observation_pt) + tm_dots(col = "red", shape=16, size=0.6)
```

So how the package works? Below is the list of functions currently developed to create detection matrix for a species. 

```{r echo=FALSE}
functions <- c("timeFormat()", "df2Spatial()", "meanPoint()", "clearPoint()","dist3D()", "speciesDM()")

purposes <- c("reformat time",
              "Convert dataframe to spatial object dataframe",
              "Calculate the means of points",
              "Clear the points from points",
              "Calculate distance based on X, Y, and Z information from a dataframe",
              "Extract detection matrix from the species observation")

arguments <- c("myString, addTime", 
               "dataFrame, UTMZone", 
               "dataFrame, nPoint", 
               "dataFrame, UTMZone, distLength", 
               "dataFrame, elevData, repLength",
               "speciesDF, speciesCol, species, extractVars")

r_functions <- data.frame(functions, purposes, arguments)
colnames(r_functions) <- c("Function", "Purpose", "Arguments/inputs")
```

```{r tab_1, caption = "test", echo=FALSE}
library(knitr)
library(kableExtra)
r_functions %>% 
  kbl() %>% 
  kable_styling()
```
## 1. Prepare track and observation points (to be updated)
We need at least three information to be able to calculate distance; Date-Time, X and Y coordinates. Date and Time should be in as.POSIXct format, while X and Y in numeric or double format. However, sometime Date and Time format we got (from GPS) is in different format (mostly as.character). For this case we need to use **track2dm::timeFormat()** function. See codes below on how to use it and how it produces the right format. We do the same for observation data.
```{r }
# Check the structure of the data
track %>% str()
observation %>%  str()

# Change Date and Time format 
library(stringr)
track_1 <- track %>% 
  dplyr::mutate(DateTime = track2dm::timeFormat(DateTime))

# Add +7 hours since the time format is in UTC
observation_1 <- observation %>%
  dplyr::mutate(DateTime = track2dm::timeFormat(DateTime, addTime = "07"))

# Check again the format
track_1 %>% str()
observation_1 %>% str()

```
In high altitudes area like in Sumatra, GPS signals may be obstructed by the altitude differences or simply canopy cover and thus produces less precise points of location. This could be a huge problem because it will calculate a bias length of distance, especially when we want to calculate research or patrol effort (in terms of length of transect surveys). To deal with this, functions called **track2dm::meanPoint** or/and **track2dm::clearPoint** will be used to remove the bias either by take means from a number of subsequent points (*meanPoint*) or clear a certain number of points between points based on a predefined distance (*clearPoint*). For example we used **meanPoint** for track_1 data.

```{r }
# Take means from every 10 coordinates (nPoint = 10)
track_2 <- track2dm::meanPoint(dataFrame = track_1, nPoint = 10)

```

```{r fig_2, out.width='75%', fig.align='center',  fig.pos="H", fig.cap="Reducing number of points by taking the means for every 10 subsequent points (showing the first 500 points)", collapse = TRUE, echo = FALSE}
# Show subsets of points to see the differences clearly
track_1_sub <- track_1[c(1:500),]

# Take means from every 10 coordinates (nPoint = 10)
track_2_sub <- track2dm::meanPoint(dataFrame = track_1_sub, nPoint = 10)

# plot the differences
par(mfrow=c(1,2))
plot(track_1_sub$X, track_1_sub$Y, pch=15, col="blue", cex=0.6, las=1, cex.axis=0.5)
plot(track_2_sub$X, track_2_sub$Y, pch=16, col="red", cex=0.6, las=1, cex.axis=0.5)
par(mfrow=c(1,1))

```

Now we can combine the cleaned track and observation into one data-frame.

```{r }
# Combine both track and observation
transect <- dplyr::full_join(track_2, observation_1, by = c("DateTime", "X", "Y")) %>%
  dplyr::arrange(DateTime, X, Y)
head(transect)

```
## 2. Calculate distance (to be updated)
After that we can calculate the distances in three dimension (X, Y, and Z). In order to do it, we need Z information and we can get it from elevation data in raster format downloaded from USGS website (https://earthexplorer.usgs.gov). We nead to load the elevation data first (as we did in the beginning).

```{r }
# Calculate 3D distance and matrix replicate
transect_rep <- track2dm::dist3D(dataFrame = transect, elevData = elevation,  repLength = 1000)
head(transect_rep)
```

## 3. Extract detection matrix for species (to be updated)
Finally, we can extract detection matrix from selected species.

```{r }
# Calculate 3D distance and matrix replicate
transect_dm <- track2dm::speciesDM(speciesDF = transect_rep, speciesCol = "Observation", species = "Tanda Satwa", extractVars = c("Age", "Type"))
transect_dm

```
What we really need is the matrix consists of the replications and the species presence/absence for further occupancy analysis. This can be done using the following script.

```{r }
# transpose it and convert as dataframe 
transect_dm_1 <- transect_dm %>% dplyr::select(Presence) %>% 
  t() %>% as.data.frame()

# Use the replicate as column names
names(transect_dm_1) <- transect_dm$Replicate
transect_dm_1
```
This is the final result where the presence absence of species is recorded for each track segment. This can be read as: from the first to fourth segment, no species were recorded. It was until the fifth segment that the species were recorded, and so on. The result would be different if we used different replicate length (*repLength*).


**Next, how to do this for multiple tracks??**
